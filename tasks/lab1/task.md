Руководство и задания к 1-ой практике. На практике поработаем с запросами и потренируемся с HTML версткой.

Для удобства, если экран позволяет, можете перенести файл md в правую часть экрана, тогда можно будет делать код и 
смотреть в руководство. Для этого нажмите правой кнопкой мыши на файл наверху и выберите `Split and Move Right`

![0.png](pic_for_task/0.png)

И далее нажмите на значок превью, чтобы включить отображения md файла на всё окно.

![0_1.png](pic_for_task/0_1.png)

Теперь можно в левой части писать и редактировать код, а в правой читать руководство. Если необходимо закрыть разделение экрана,
то просто закройте файл в правом окне. 

### 1. Работа с запросами к сервису погоды

Будем рассматривать 2 подхода к использованию ключа API сервиса погоды.

#### 1.1 Использование ключа в параметрах запроса

Получение ключа для API будем производить через сервис https://www.weatherapi.com/ 

Регистрируемся, если не зарегистрированы https://www.weatherapi.com/signup.aspx и подтверждаем почту

После регистрации автоматически появится версия Pro+ на 14 дней, если планируете продолжить пользоваться, то можно перейти
на бесплатную базовую версию.

Для создания запросов к сервису будет необходим API ключ, который находится во вкладке `Dashboard`

![1.png](pic_for_task/1.png)

Примеры запросов можно посмотреть в документации https://www.weatherapi.com/docs/

##### *Создание запросов через адресную строку браузера*

Чаще всего доступ к API идёт через параметры запроса, то возвращаемую информацию можно посмотреть через браузер

Вот пример запроса к данному сервису 

`https://api.weatherapi.com/v1/current.json?key=<YOUR_API_KEY>&q=London`

здесь:
* `key` - ваш ключ доступа
* `q` - локация, где необходимо получить данные. Локацию можно задавать как именем города, так и координатами широта, 
долгота (`q=<lat>,<lon>`), как пример `q=51.52,-0.11`

##### Самостоятельно

Через браузер получите данные о погоде с использованием вашего ключа и желаемой области

Ниже приведен пример запроса для получения данных о погоде для Санкт-Петербурга

`https://api.weatherapi.com/v1/current.json?key=b4588e45fcc14bdb89d63200232109&q=59.93,30.31`

![2.png](pic_for_task/2.png)

##### *Создание запросов через команду curl*

Также можно использовать команду `curl` в консоли(`Terminal` PyCharm), чтобы получить информацию от сайта. Для корректной работы необходимо
адрес обернуть в кавычки.

```cmd
curl "https://api.weatherapi.com/v1/current.json?key=b4588e45fcc14bdb89d63200232109&q=59.93,30.31"
```

![3.png](pic_for_task/3.png)

Если при выполнении появилась ошибка 
```cmd
curl: (35) schannel: next InitializeSecurityContext failed: Unknown error (0x80092012) - Функция отзыва не смогла произвести проверку отзыва для сертификата."
```
то необходимо указать, чтобы запрос был произведен без проверки сертификата SSL

Добавление параметра `--insecure` в команду Curl позволит пропустить проверку сертификата SSL. Однако будьте осторожны при использовании этой опции, поскольку она делает ваше соединение менее безопасным.

```cmd
curl --insecure "https://api.weatherapi.com/v1/current.json?key=b4588e45fcc14bdb89d63200232109&q=59.93,30.31"
```

##### *Создание запросов через модуль requests*

У Python есть сторонний модуль `requests` для работы с запросами. Сделаем запрос с использованием `Python Console` PyCharm

```python
import requests

key = ""  # TODO подставить ваш ключ к API
lat = "59.93"  # широта в градусах
lon = "30.31"  # долгота в градусах

url = f"https://api.weatherapi.com/v1/current.json?key={key}&q={lat},{lon}"
response = requests.get(url)  # отправление GET запроса и получение ответа от сервера
print(response.json())  # получение JSON из ответа
```

![4.png](pic_for_task/4.png)

#### 1.2 Использование ключа в заголовке запроса

В этот раз воспользуемся сервисом Яндекса

Необходимо зайти под аккаунтом яндекса и перейти в кабинет разработчика https://developer.tech.yandex.ru/, 
где подключим `API Яндекс.Погоды`

![5.png](pic_for_task/5.png)

![6.png](pic_for_task/6.png)

Далее заполняем форму, бесплатного тарифа в 50 запросов в день будет достаточно

![7.png](pic_for_task/7.png)

Переходим в кабинет разработчика и используем предложенный ключ API

![8.png](pic_for_task/8.png)

![9.png](pic_for_task/9.png)

По умолчанию тариф будет стоять Тестовый. Если есть необходимость его можно понизить до «Погода на вашем сайте» у кнопки
Тарифы

Как использовать API описано в https://yandex.ru/dev/weather/doc/dg/concepts/forecast-info.html

##### *Создание запросов через адресную строку браузера*

Обратимся к API через адресную строку

`https://api.weather.yandex.ru/v2/forecast?lat=59.93&lon=30.31`

И получим, что нет доступа, так как ключ к API необходимо передавать через заголовок, а через адресную строку это 
передать не выйдет

![10.png](pic_for_task/10.png)


##### *Создание запросов через команду curl*
`Так как необходимо определенное время, чтобы сохранить ключи сервисом Яндекс погода, то
доступа к API через ключ может не быть определенное время, в среднем 5-10 минут, поэтому начните читать раздел "3. Работа с HTML файлами и вёрсткой" данного руководства и после 5 минут ожидания возвращайтесь к продолжению работы с api `
 
У curl есть параметр `-H` отвечающий за формирование заголовка в запросе. У сервиса яндекс погоды есть требование как 
должен называться заголовок в котором будет передаваться ключ в общем виде это `X-Yandex-API-Key: <значение вашего ключа>`

Пример запроса (подставьте значение вашего ключа!)

`curl -H "X-Yandex-API-Key: 54d73608-c8dd-4c98-b18f-d9a5056525ab" "https://api.weather.yandex.ru/v2/forecast?lat=59.93&lon=30.31"`

![11.png](pic_for_task/11.png)

Важное замечание! У Яндекс погоды есть два тарифа тестовый (на 14 дней) и бесплатный (бессрочный, но с ограничением в 50 запросов в день).
Отличаются эти тарифы ссылками на которые нужно посылать запрос:

* Тариф «Тестовый». `https://api.weather.yandex.ru/v2/forecast?lat=59.93&lon=30.31`
* Тариф «Погода на вашем сайте» `https://api.weather.yandex.ru/v2/informers?lat=59.93&lon=30.31`

Отличаются они ограничениями на число запросов, и определенным функционалом. Если планируете пользоваться им далее, то в будущем придётся перейти
на бесплатный тариф, а у него часть функционала недоступна (об этом будет рассказано в пункте 1.3). 
Если самостоятельно перешли на тариф «Погода на вашем сайте», то необходимо использовать `informers` вместо `forecast`

В случае если при отправки запроса через `curl` получили ошибку `curl: (35) schannel: next InitializeSecurityContext failed`

```cmd
curl: (35) schannel: next InitializeSecurityContext failed: Unknown error (0x80092012) - Функция отзыва не смогла произвести проверку отзыва для сертификата.
```

добавьте `--insecure`

`curl --insecure -H "X-Yandex-API-Key: 54d73608-c8dd-4c98-b18f-d9a5056525ab" "https://api.weather.yandex.ru/v2/forecast?lat=59.93&lon=30.31"`

##### *Создание запросов через модуль requests*

Для работы с заголовками у `requests` есть параметр `headers` в который в виде словаря передаются заголовки и их значения

```python
import requests

key = ""  # TODO подставьте значение вашего ключа доступа к API
lat = "59.93"  # широта в градусах
lon = "30.31"  # долгота в градусах

url = f"https://api.weather.yandex.ru/v2/forecast?lat={lat}&lon={lon}"
headers={"X-Yandex-API-Key": f"{key}"}

response = requests.get(url, headers=headers)
print(response.json())
```
![12.png](pic_for_task/12.png)


#### 1.3 Реализация функции работы с API 

Скопируйте файл `weather_api.py` из папки `files/lab1` в корень проекта (в папку DjangoPY110. 
`weather_api.py` должен лежать вместе с `requirements.txt` и `.gitignore`).  

Далее `git` предложит добавить файл в систему индексации `git` (для отслеживания изменений 
в данном файле). Добавим этот файл нажав на `Add` 

![13.png](pic_for_task/13.png)

Если по каким-то причинам файл не добавился (название файла горит красным цветом), то можно это сделать вручную, для этого
правой кнопкой мыши щелкните на файле далее `Git` далее `Add`

![14.png](pic_for_task/14.png)

В случае добавления файла в систему индексации, то имя файла будет гореть зелёным

![15.png](pic_for_task/15.png)


В `weather_api.py` необходимо дописать функцию `current_weather`, которая отвечает за возвращение данных о погоде по заданным координатам.
Функция использует API Яндекс Погоды, которую рассматривали ранее.

В функции необходимо:
* Аннотировать входные и выходные переменные. Должно быть описание функции.
* Подставить свой ключ для API Яндекс погоды
* Дописать реализацию значений ключей в переменной `result` для Яндекс погоды (как написать реализацию, написано ниже)
  * `temp`;
  * `feels_like_temp`;
  * `pressure`;
  * `humidity`;
  * `wind_speed`;
  * `wind_gust`.

Информация о значении ключей переменной `result` и где получать значения и результата ответа от API:

| Ключ  возвращаемого словаря                                           | Получение значения из API Яндекс Погода                                                                                                                            | Получение значения из API weatherapi                                                                                                                                                               |
|-----------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `city` (город)                                                        | `['geo_object']['locality']['name']`                                                                                                                               | `['location']['name']`                                                                                                                                                                             |
| `time` (время когда было обновление информации) <br/>[формат час:мин] | `['fact']['uptime']` - возвращает время в целом значении секунд, для перевода к формату datetime можно воспользоваться методом `fromtimestamp` подробнее в примере | `['current']['last_updated']`                                                                                                                                                                      |
| `temp` (температура) [градус Цельсия]                                 | `['fact']['temp']`                                                                                                                                                 | `['current']['temp_c']`                                                                                                                                                                            |
| `feels_like_temp` (ощущаемая температура) [градус Цельсия]            | `['fact']['feels_like']`                                                                                                                                           | `['current']['feelslike_c']`                                                                                                                                                                       |
| `pressure` (давление) [мм. ртутного столба]                           | `['fact']['pressure_mm']`                                                                                                                                          | `['current']['pressure_mb']` - возвращает давление в ГПа, необходимо перевести в мм. ртутного столба, для этого давление необходимо умножить на 0.75, результат округлить до 1 знака после запятой |
| `humidity` (влажность) [%]                                            | `['fact']['humidity']`                                                                                                                                             | `['current']['humidity']`                                                                                                                                                                          |
| `wind_speed` (скорость ветра) [м/с]                                   | `['fact']['wind_speed']`                                                                                                                                           | `['current']['wind_kph']` -  возвращает скорость в км/ч необходимо перевести в м/с, для этого скорость нужно поделить на 3.6, результат округлить до 1 знака после запятой                         |
| `wind_gust` (порывы ветра) [м/с]                                      | `['fact']['wind_gust']`                                                                                                                                            | `['current']['gust_kph']` - возвращает скорость порывов в км/ч, необходимо перевести в м/с, результат округлить до 1 знака после запятой)                                                          |
| `wind_dir` (направление ветра)                                        | `['fact']['wind_dir']` - возвращает латинское обозначение направления с *маленькой* буквы                                                                          | `['current']['wind_dir']` - возвращает латинское обозначение направления с *большой* буквы                                                                                                         |


Кто хочет, тот может реализовать две функции на разных API, чтобы посмотреть, как отличаются данные разных сервисов.

Функция `current_weather` будет использована в следующей лабораторной работе.

Пример работы функции `current_weather` для API Яндекс Погода

![17.png](pic_for_task/17.png)

### 2. Создание коммитов и отправление изменений на github

Создадим коммит наших изменений проекта (реализация `weather_api.py`)

Для этого нажимаем на зеленую галочку вверху справа `PyCharm` или во вкладке `Git` нажимаем `Commit`

![18.png](pic_for_task/18.png)

Далее появится форма, где можно будет посмотреть те изменения, которые вы хотите зафиксировать в системе контроля версий.

Назовите коммит и нажмите `Commit`

![19.png](pic_for_task/19.png)

Название файла `weather_api.py` перестало как-то светиться, значит коммит с этим файлом был сформирован.

![20.png](pic_for_task/20.png)

Процедура создания коммитов необходима для добавления изменений в систему контроля версий, однако, данные изменения есть
на вашей локальной машине, чтобы перенести эти изменения на сервер `github`, то воспользуемся процедурой `Push`.

Для этого нажмём на зелёную стрелку вверху справа `PyCharm` или во вкладке `Git` нажимаем `Push`

![21.png](pic_for_task/21.png)

Откроется окно с информацией от коммитах, что собираетесь передать. Для передачи нажмём на `Push`

![22.png](pic_for_task/22.png)

Теперь ваш коммит есть на `github`, а значит и весь тот код, что написали в `weather_api.py` - теперь есть на `github`

### 3. Работа с HTML файлами и вёрсткой

В данной части практики рассмотрим создание и заполнение HTML5, а так же работу с каскадными стилями CSS. 

В модуле PY110 будут рассмотрены основные элементы и атрибуты HTML для понимания HTML файлов.
Наша задача научиться понимать файл HTML, а не уметь его создавать с нуля.

#### *Работа с HTML в PyCharm*

Создайте HTML файл `example.html` через обозреватель `PyCharm` в вашей корневой папке проекта. Почему через `PyCharm`?
`PyCharm` автоматически подготовит простейшую структуру `HTML` файла.

![23.png](pic_for_task/23.png)

Структура документа HTML созданного PyCharm

![24.png](pic_for_task/24.png)

В `example.html` есть следующие элементы:

* `<!DOCTYPE html>`: Объявление типа документа и начало HTML5-документа.


* `<html>`: Корневой элемент HTML-документа, который охватывает все содержимое страницы.


* `<head>`: Секция, содержащая метаданные и ссылки на внешние ресурсы, такие как стили, скрипты и мета-теги.


* `<meta>`: Используется для задания метаданных, таких как кодировка символов, описание, ключевые слова и другие.


* `<title>`: Определяет заголовок страницы, который отображается в заголовке веб-браузера или на вкладке.


* `<body>`: Описывает основную часть веб-страницы, которая видна пользователям в их веб-браузерах. 
Внутри элемента `<body>` размещается весь текст, изображения, ссылки, мультимедийный контент, формы и другие элементы, 
которые пользователи видят и с которыми взаимодействуют при посещении веб-страницы.

Как видите есть открывающиеся и закрывающиеся теги, на примере `<body>...</body>`, а есть теги которые не нужно закрывать 
как `<meta>`.

Весь контент на сайте, как правило, стараются описать между тегом `<body>`.

`PyCharm` позволяет просмотреть HTML файл как через встроенный обозреватель (preview), так и через обозреватель которые 
есть на вашем компьютере. Данные кнопки отображаются в самом файле в правой части экрана.

![25.png](pic_for_task/25.png)

Попробуйте открыть файл через встроенный и внешний обозреватель и вы увидите белый экран, так как никакой информации для
вас пока нет в файле, то, что написано это базовые конструкции для обозревателя.

По умолчанию обновление отображения содержимого HTML (в случае изменения содержимого) во встроенном браузере идёт 
при сохранении файла HTML, но в настройках это можно изменить если необходимо.

![26.png](pic_for_task/26.png)


Для того чтобы отобразить такой-то текст, тег не нужен, можно просто в любом месте написать что угодно между открытым 
и закрытым тегом `<body>`

Для примера напишите 'Политех' и теперь у нас уже не пустой лист.

![27.png](pic_for_task/27.png)

Но форматирование текста выглядит не так как нам привычно. Допустим переход на новую строку и текст с большими пробелами
будет отображаться не так как мы написали.

![28.png](pic_for_task/28.png)

В этом и кроется краеугольный камень, всё форматирование идёт через теги, чтобы можно было убрать лишние пробелы и более
ёмко передавать данные по сети. Лишний пробел, лишняя и ненужная информация для компьютера, хотя человеку и приятнее 
читать с разделителями, чем без. 

Поэтому лишние пробелы и табуляция не будут влиять на отображении в браузере, но сделают вашу верстку более читаемой.

Элементы HTML можно использовать внутри друг друга, как бы обрамляя собой другие теги, данный подход делает вашу верстку
более гибкой.

#### *Основные элементы HTML5 (теория)*

Сокращённо (хотя выглядит не сильно сокращённо) у `HTML` и `CSS` можно выделить следующие аспекты:

1. Комментарии в HTML оставляются между символов `<!-- и -->`

```html
<!-- это строка комментарий -->
<!--
А это
многострочный
комментарий
-->
```

2. `Теги HTML`. Весь файл HTML состоит из тегов (элементов). Внутри тега можно использовать свойства. Между открывающимся и закрывающимся тегом
можно использовать содержимое для отображения на странице.

![30.png](pic_for_task/30.png)

3. `Атрибуты тега`. У каждого тега есть атрибуты позволяющие настроить поведение данного тега.

Атрибуты можно разделить на следующие группы:

* `Универсальные`. Атрибуты, которые есть в каждом теге.

* `Уникальные`. Атрибуты, которые есть только в данном теге.

* `Специфические`. Атрибуты, которые есть только в группе тегов.

* `Событийние`. Атрибуты для взаимодействия с событиями JavaScript.


![31.png](pic_for_task/31.png)

4. `Одиночные` и `парные` теги. Условно теги по специфике можно разделить на `одиночные`(нет закрывающегося тега. Тут вся информация
идёт в основном через свойства) и `парные` (есть закрывающийся тег. Между открытым и закрытым тегом можно прописать содержимое
к которому будет применено действие данного парного тега).

![32.png](pic_for_task/32.png)

5. `Блочные` и `строчные` теги. 

В HTML элементы можно разделить на две основные категории: блочные и строчные (или инлайновые). 
Эти категории определяют, как элементы отображаются на веб-странице и как они взаимодействуют друг с другом. 

![33.png](pic_for_task/33.png)

Вот основные различия между блочными и строчными элементами:

`Блочные элементы`:

* `Отображение на новой строке`: Блочные элементы всегда начинаются с новой строки и занимают всю доступную 
горизонтальную ширину, заполняя всю ширину родительского контейнера.

* `Горизонтальная ширина`: Блочные элементы занимают всю доступную горизонтальную ширину, пока не задано какое-либо 
ограничение ширины.

* `Вертикальные отступы`: Блочные элементы автоматически добавляют вертикальные отступы (отступы сверху и снизу), 
создавая пространство между соседними элементами.

* `Игнорирование ширины элементов`: Блочные элементы игнорируют инлайновые элементы, находящиеся слева или справа от 
них на той же строке.

Примеры блочных элементов в HTML: `<div>`, `<p>`, `<h1>`, `<ul>`, `<li>`, `<section>`, `<article>`.

`Строчные (инлайновые) элементы`:

* `Отображение на той же строке`: Строчные элементы отображаются на той же строке, что и соседние строчные элементы, 
и не начинают новую строку.

* `Горизонтальная ширина`: Строчные элементы занимают только необходимую для содержимого горизонтальную ширину. 
Они не занимают всю доступную ширину родительского контейнера.

* `Отсутствие вертикальных отступов`: Строчные элементы не автоматически добавляют вертикальные отступы сверху и снизу, 
их размер зависит от содержимого.

* `Можно смешивать на одной строке`: Строчные элементы могут быть вложены друг в друга и смешиваться на одной строке.

Примеры строчных элементов в HTML: `<span>`, `<a>`, `<strong>`, `<em>`, `<img>`, `<br>`, `<input>`, `<button>`.

6. `Теги разделов HTML`. HTML предоставляет различные теги разделов, которые служат для структурирования и организации 
содержимого веб-страницы. Эти теги используются для логического разделения и группировки контента, 
делая веб-страницы более читаемыми, семантичными и понятными для поисковых систем и программ чтения с экрана.


![34.png](pic_for_task/34.png)

Вот некоторые из наиболее часто используемых тегов разделов HTML и их предназначение:

* `<header>`: Этот тег предназначен для определения заголовка или шапки раздела или всей страницы. 
Обычно включает в себя заголовки, логотип, навигационные элементы и другую важную информацию.

* `<nav>`: Используется для определения навигационных ссылок, меню или панели навигации. Обычно включает в себя ссылки 
на разделы сайта или другие ключевые страницы.

* `<main>`: Определяет основное содержимое документа. Веб-страница может содержать только один элемент `<main>`, 
и это основное место для основного контента страницы.

* `<article>`: Этот тег используется для обозначения независимой, самодостаточной статьи или блока контента на странице. 
Элемент `<article>` может быть использован для новостей, статей, постов в блоге и другого подобного контента.

* `<section>`: Элемент `<section>` определяет логический раздел или блок контента на странице. Он может быть использован 
для группировки связанных элементов внутри страницы.

* `<aside>`: Этот тег обозначает дополнительный контент, который часто бывает второстепенным по отношению к основному 
содержимому страницы. Это может быть сайдбар, блок с рекламой, списком ссылок и другим дополнительным контентом.

* `<footer>`: Элемент `<footer>` определяет нижнюю часть раздела, статьи или всей страницы. Обычно содержит информацию 
о авторстве, контактную информацию, ссылки на социальные сети, дату публикации и другую сопутствующую информацию.


7. `Загрузка и импорт сторонних файлов в HTML`.

* `Ссылка на внешний HTML файл`: Вы можете создать гиперссылку на другой `HTML` файл, используя элемент `<a>` (гиперссылка). 
Пример:

```html
<a href="другой-файл.html">Ссылка на другой HTML файл</a>
```

*  `Вставка HTML файла с помощью <iframe>`: Элемент `<iframe>` позволяет вставлять другой HTML файл внутри текущей страницы. 
Пример:

```html
<iframe src="другой-файл.html" width="500" height="300"></iframe>
```


8. `Работа со сценариями`. Сценарии в `HTML` обеспечивают интерактивность и динамичность веб-страниц, позволяя выполнять 
различные действия и операции на стороне клиента. Основными языками для создания сценариев в `HTML` являются `JavaScript` и, 
в некоторых случаях, `TypeScript`. Вот основная информация о сценариях в HTML:

*Использование сценариев в HTML*:

* `Интерактивные элементы`: Сценарии позволяют создавать интерактивные элементы, такие как кнопки, формы для ввода данных, 
вкладки, выпадающие списки и многое другое.

* `Обработка событий`: JavaScript позволяет привязывать функции к событиям элементов на веб-странице, таким как щелчки, 
наведение курсора, отправка формы и другие.

* `Динамическое обновление контента`: Вы можете изменять или обновлять содержимое веб-страницы без перезагрузки страницы. 
Это особенно полезно для создания одностраничных приложений (SPA) и динамических веб-сайтов.

* `Валидация данных`: Сценарии могут использоваться для проверки и валидации данных, введенных пользователем в формах, 
до их отправки на сервер.

* `Анимации и визуальные эффекты`: JavaScript может быть использован для создания анимаций и визуальных эффектов на веб-страницах.

Один из примеров работы JavaScript в области анимации можете наблюдать в файле `cosmo.html` в `files/lab1`. Анализировать код не нужно, просто запустить.

*Загрузка сценариев в HTML*:

* `Тег <script>`: Вы можете использовать тег `<script>` для вставки сценариев непосредственно в HTML. Например:

```html
<script>
    // JavaScript код здесь
</script>
```

* `Внешние файлы`: Вы можете создать отдельные файлы с JavaScript-кодом и загрузить их в HTML с помощью тега `<script>` с атрибутом `src`.
Пример:

```html
<script src="script.js"></script>
```

* `Асинхронная или отложенная загрузка`: Атрибуты `async` и `defer` могут использоваться в теге `<script>`, 
чтобы управлять порядком загрузки и выполнения сценариев. Например:

```html
<script src="script1.js" async></script>
<script src="script2.js" defer></script>
```
`async` позволяет загрузить сценарий асинхронно, не блокируя отрисовку страницы, а `defer` загружает сценарий асинхронно, 
но выполнение будет отложено до завершения парсинга HTML.

Обычно сценарии помещают внутрь элемента `<head>` перед закрывающим `</body>` тегом, чтобы обеспечить оптимальную производительность загрузки страницы.


9. `Каскадные таблицы стилей CSS`.

`HTML` теги служат для определения структуры и семантики веб-страницы, но не предназначены для управления позиционированием 
элементов на странице. Для управления расположением и стилем блоков обычно используется `CSS` (Cascading Style Sheets).

`HTML` определяет структуру контента, такую как заголовки, параграфы, списки и таблицы, но не предоставляет средства 
для задания точного местоположения элементов на странице. `CSS`, с другой стороны, предоставляет множество свойств и методов 
для управления макетом, размерами, цветами и другими аспектами визуального представления веб-страницы.

В общем случае элемент стиля состоит из селектора (показывает к какому атрибуту HTML применить данный стиль) и набора правил 
обрамленные фигурными скобками `{`,`}`.  Правило формируется в виде `<свойство>:<значение>`. Правила в наборе 
отделяются друг от друга символом `;`. 

![35.png](pic_for_task/35.png)


10. `Селекторы и свойства CSS`. В `CSS` существует несколько различных типов селекторов, которые определяют, к каким 
элементам `HTML` будет применяться стиль. Вот наиболее часто используемые типы селекторов:


* `Универсальный селектор (Universal Selector)`: Этот селектор выбирает все элементы на странице. Универсальный селектор 
обозначается символом `*`. Например:

```css
* {
    /* стили для всех элементов на странице */
}
```
Пример использования в `HTML`
```html
<style>
    * {
        /* стили для всех элементов на странице */
        color: green;
}
</style>
<p>Этот текст стилизован</p>
<span>А тот тоже</span><br>
<button>Эта кнопка тоже</button>
```
![36.png](pic_for_task/36.png)

* `Селектор по типу элемента (Type Selector)`: Этот селектор выбирает все элементы определенного типа. Например, 
чтобы стилизовать все абзацы `<p>`, используйте следующий селектор:

```css
p { 
       /* стили для абзацев */
}
```
Пример использования в `HTML`
```html
<style>
    p { 
        /* стили для абзацев */
        color: green; /* весь текст зеленого цвета в теге <p> */
    }
</style>
<p>Это текcт стилизован</p>
<p>И этот тоже</p>
```

![37.png](pic_for_task/37.png)

* `Селектор по классу (Class Selector)`: Этот селектор выбирает элементы, которые имеют определенный класс (атрибут 
`class` у HTML тега). Класс указывается с точкой перед именем класса. Например:

```css
.my-class {
    /* стили для элементов с классом my-class */
}
```
Пример использования в `HTML`
```html
<style>
    .my-class {
        /* стили для элементов с классом my-class */
        color: green; /* весь текст зеленого цвета для класса class='my-class' */
    }
</style>
<p class="my-class">Это текcт стилизован</p>
<p>А этот нет. <span class="my-class">А этот да!</span></p>
```
![38.png](pic_for_task/38.png)

* `Селектор по идентификатору (ID Selector)`: Этот селектор выбирает элемент по его уникальному идентификатору. 
Идентификатор указывается с символом `#` перед именем идентификатора (имя идентификатора равно значению атрибута `id`).
Например:

```css
#my-element {
    /* стили для элемента с идентификатором my-element */
}
```
Пример использования в `HTML`
```html
<style>
    #my-element {
        /* стили для элемента с идентификатором my-element */
        color: green; /* весь текст зеленого цвета для атрибута id='my-element' */
    }
</style>
<p id="my-element">Это текcт стилизован</p>
<p>А этот нет.</p>
```

![39.png](pic_for_task/39.png)

Значение атрибута `id` должно быть уникальным внутри всего HTML-документа. Это означает, что два или более элемента не могут 
иметь одинаковое значение `id`. Если вам нужно сделать несколько элементов похожими или связанными между собой, вы можете 
использовать атрибут `class` вместо `id`.

* `Селектор по атрибуту (Attribute Selector)`: Этот селектор выбирает элементы, которые имеют определенный атрибут и, 
возможно, соответствующее значение атрибута. Например:

```css
input[type="reset"] {
    /* стили для всех input с атрибутом type="reset" */
}
```
Пример использования в `HTML`
```html
<style>
    input[type="reset"] {
        /* стили для всех input с атрибутом type="reset" */
        color: green;
        background: orange;
}
</style>
Эта кнопка стилизована <input type="reset" value="Button"><br>
А эта нет <input type="button" value="Button">
```

* `Селектор по потомству (Descendant Selector)`: Этот селектор выбирает элемент, который является потомком другого элемента. 
Селекторы разделяются пробелом. Например:

```css
article p {
    /* стили для всех элементов <p>, которые являются потомками элементов <article> */
}
```
Пример использования в `HTML`
```html
<style>
    article p {
        /* стили для всех элементов <p>, которые являются потомками элементов <article> */
        color: green;
        background: orange;
}
</style>
<article>
    <p>Этот текст стилизован</p>
    <span>А этот нет</span>
</article>
```
![40.png](pic_for_task/40.png)

* `Селектор по псевдоклассу (Pseudo-class Selector)`: Этот селектор выбирает элементы на основе их состояния или позиции 
в структуре документа. Список псевдоклассов есть в `html_css.md`. Например, `:hover` выбирает элемент, над которым находится указатель мыши:

```css
a:hover {
    /* стили для ссылок при наведении на них курсора */
}
```
Пример использования в `HTML`
```html
<style>
    a:hover {
        /* стили для ссылок при наведении на них курсора */
        color: red;
}
</style>
<a>Ссылка</a>
```

![41.png](pic_for_task/41.png)

* `Селектор по псевдоэлементу (Pseudo-element Selector)`: Этот селектор выбирает определенные части элементов, такие 
как первая буква или первая строка текста. Список псевдоэлементов есть в `html_css.md`. Например:

```css
p::first-line {
    /* стили для первой строки текста внутри абзаца */
}

```
Пример использования в `HTML`
```html
<style>
    p::first-line {
        /* стили для первой строки текста внутри абзаца */
        background: #ff6a7d;
}
</style>
<p>Первая строка<br>Вторая строка<br>Третья строка</p>
```
![42.png](pic_for_task/42.png)


* `Групповые селекторы`: При перечислении любых селекторов через запятую им можно задать одинаковые свойства.

```css
p, .my-class, #my-element {
    /* список стилей с одинаковыми правилами */
}
```
Пример использования в `HTML`
```html
<style>
    p, .my-class, #my-element {
        /* список стилей с одинаковыми правилами */
        background: #ff6a7d;
}
</style>
<p>Первая строка<br>Вторая строка<br>Третья строка</p>
<span class="my-class">Строка</span><br>
<div id="my-element">
    Элемент
</div>
```

![43.png](pic_for_task/43.png)


11. `Свойства CSS для размещения элементов HTML на странице`.

Для размещения элементов HTML на веб-странице в CSS существует несколько свойств и техник. Вот некоторые из наиболее 
часто используемых свойств CSS для управления расположением элементов:

* `position`: Это свойство определяет метод размещения элемента на странице. Возможные значения:

  * `static` (по умолчанию): Элемент размещается в соответствии с нормальным потоком документа.
  * `relative`: Элемент позиционируется относительно своего нормального местоположения. 
  Вы можете использовать свойства `top`, `right`, `bottom` и `left` для смещения элемента.
  * `absolute`: Элемент позиционируется относительно ближайшего позиционированного (не static) родительского элемента 
  или относительно окна браузера, если у родительского элемента нет позиции.
  * `fixed`: Элемент позиционируется относительно окна браузера и остается на месте, даже если страница прокручивается.

```css
.my-element {
    position: relative;
    top: 20px;
    left: 30px;
}
```

* `margin` (Внешний отступ): Это свойство определяет внешние отступы элемента и влияет на расстояние между элементами на странице.

  * `margin-top`: Отступ сверху от контейнера.
  * `margin-right`: Отступ справа от контейнера.
  * `margin-bottom`: Отступ снизу от контейнера.
  * `margin-left`: Отступ слева от контейнера.

```css
.my-element {
    margin-top: 10px;
    margin-right: 20px;
    margin-bottom: 10px;
    margin-left: 20px;
}
```


* `display`: Это свойство управляет типом отображения элемента. Возможные значения:

  * `block`: Элемент отображается как блочный элемент, который занимает всю доступную ширину и начинается с новой строки.
  * `inline`: Элемент отображается как инлайновый элемент, который занимает только необходимую горизонтальную ширину и 
  не начинает новой строки.
  * `inline-block`: Элемент отображается как инлайн-блок, который комбинирует свойства блочного и инлайнового элементов.
  * `none`: Элемент не отображается на странице и не занимает места.

```css
.my-element {
    display: inline-block;
}
```

* `float`: Это свойство позволяет элементам "плавать" вокруг других элементов. 
Это часто используется для создания многоколоночного макета.

  * `left`: Элемент будет обтекаться с левой стороны.
  * `right`: Элемент будет обтекаться с правой стороны.
  * `both`: Элемент будет обтекаться и слева, и справа.

```css
.my-element {
    float: left;
}
```

12. `Использование и загрузка стилей CSS в HTML`.

И последнее, что нужно рассмотреть это использование и загрузка стилей в HTML файл.

* `Вставка стилей внутри HTML с использованием <style>`: Если вы хотите вставить `CSS` стили непосредственно в `HTML` файл, 
используйте элемент `<style>` внутри `<head>`. Пример:

```html
<style>
    body {
        background-color: lightgray;
        font-family: Arial, sans-serif;
    }
</style>
```

* `Внедрение CSS стилей с использованием <style> внутри HTML элементов`: Вы также можете встроить `CSS` стили непосредственно 
в `HTML` элементы с помощью атрибута `style`. Пример:

```html
<p style="color: blue; font-size: 16px;">Текст с встроенными стилями.</p>
```

* `Ссылка на внешний CSS файл`: Чтобы загрузить внешний CSS файл, используйте элемент `<link>` внутри `<head>` вашего HTML документа. 
Пример:

```html
<link rel="stylesheet" type="text/css" href="стиль.css">
```
Это подключит стилевой файл `стиль.css` к вашему `HTML` документу.

* `Загрузка внешнего CSS-файла по ссылке`: Для загрузки внешнего CSS-файла из интернета и подключения его к вашему HTML-документу, 
вы можете использовать тег `<link>` с атрибутом `href` в разделе `<head>` вашей веб-страницы.

```html
<link rel="stylesheet" href="https://example.com/styles.css">
```

### 4. Задание

Верстальщик создал 3 `HTML` файла (все они располагаются по пути `files/lab1`):
* `nav.html` в котором хранится код для навигации блога
* `content.html` в котором хранится код с основным содержанием
* `footer.html` в котором хранится код информацией о блоге

Ваша задача собрать данные блоки в один файл.

В корне проекта создайте файл `blog.html` и внутри тега `<body>`...`</body>` внесите информацию 
в порядке информации из `nav.html`, `content.html`, `footer.html`.

Пример заполнения

![44.png](pic_for_task/44.png)

При отображении HTML файла получим файл без стилей и размещения элементов.

![45.png](pic_for_task/45.png)

Поэтому подключим CSS документ. Для подключения в разделе `<head>`...`</head>` вашего файла `blog.html` пропишем

```html
<link rel="stylesheet" type="text/css" href="files/lab1/static/blog.css">
```

Теперь есть небольшая стилизация файла.

![46.png](pic_for_task/46.png)

#### Самостоятельно

Вы получили рабочую версию вашего проекта после 1-ой практики. Сделайте коммит ваших файлов и отправьте их в ваш репозиторий на `github`.

Самостоятельно изучите теги в блоке `<body>`...`</body>` вашего файла `blog.html`, поменяйте местами теги `<header>` c `<footer>` посмотрите что изменится.

Зайдите в CSS файл `blog.css` в `files/lab1/static` и допустим поменяйте цвет навигационной панели `nav` или любого другого тега. 
Посмотрите как меняется отображение файла `blog.html` при изменении параметров в `blog.css`.

### Практика окончена

Зафиксируем изменения сделав коммит и отправим эти коммиты на github

На практике знание `HTML` и `CSS` потребуется если есть необходимость менять или создавать сложные HTML документы.
В рамках нашего обучения не будет необходимости в создании сложных HTML. 

Дополнительно про `HTML` с примерами можно ознакомиться в файле `html.md` в папке `tasks/lab1`

Если есть желание, то подробно про HTML с его элементами и атрибутами можно прочитать [здесь](https://html5book.ru/html-html5/)

А про CSS [здесь](https://html5book.ru/css-css3/) 